# [**Basic Pattern Questions**](https://www.notion.so/Basic-Pattern-Questions-2199b780968d80ee8a56f9c890f5b194?pvs=21)

# Topic: `let`, `const`, `var` – Scope and Temporal Dead Zone (TDZ)

### 📌 1. Scope Types

| Type | Description | Applies to |
| --- | --- | --- |
| Global Scope | Accessible everywhere | `var`, `let`, `const` |
| Function Scope | Accessible only inside the function | `var` only |
| Block Scope | Accessible inside `{}` blocks | `let`, `const` |

### ✅ `var` – Function Scoped & Hoisted

- Hoisted to the top of its **function scope**, initialized with `undefined`.
- No block scope.

```jsx
function test() {
  console.log(a); // undefined (hoisted)
  var a = 10;
  console.log(a); // 10
}
```

```jsx
if (true) {
  var x = 5;
}
console.log(x); // ✅ 5 — no block scope
```

### ✅ `let` – Block Scoped & TDZ Applies

- **Hoisted** but **not initialized** → causes **ReferenceError** if accessed before declaration.
- Block scoped → useful for loops, blocks.

```jsx
function test() {
  console.log(b); // ❌ ReferenceError (TDZ)
  let b = 20;
}
```

```jsx
if (true) {
  let y = 10;
}
console.log(y); // ❌ ReferenceError
```

### ✅ `const` – Block Scoped & TDZ Applies

- Same scoping behavior as `let`.
- Must be initialized at declaration.

```jsx
const z = 100;
z = 200; // ❌ TypeError – cannot reassign const
```

### ⚠️ Temporal Dead Zone (TDZ)

- Time between hoisting and actual declaration.
- Accessing variable in TDZ = **ReferenceError**.

```jsx
{
  console.log(a); // ❌ TDZ
  let a = 5;
}
```

### 📘 Use Case in DSA: Loop Variables

```jsx
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // Logs: 3, 3, 3
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // Logs: 0, 1, 2
}
```

- `let` is block-scoped → each loop iteration gets a new binding.
- `var` shares the same scope → value of `i` is 3 after the loop ends.

## 🔎 JavaScript Data Types Overview

JavaScript has **two categories** of data types:

### 📦 1. **Primitive Types**

> Stored directly in the stack memory
> 
> 
> Immutable → the actual value is stored
> 

| Type | Example |
| --- | --- |
| `Number` | `42`, `3.14` |
| `String` | `'hello'`, `"JS"` |
| `Boolean` | `true`, `false` |
| `null` | `null` |
| `undefined` | `undefined` |
| `Symbol` | `Symbol('id')` |
| `BigInt` | `12345678901234567890n` |

```jsx
let a = 10;
let b = a;
b = 20;
console.log(a); // 10 (original not changed)
```

🧠 `b` got a **copy** of the value in `a`. Changing `b` does **not** affect `a`.

### 📦 2. **Reference Types**

> Stored in heap memory, variable stores only a reference (pointer)
> 
> 
> Mutable → changes via one reference reflect everywhere
> 

| Type | Example |
| --- | --- |
| `Object` | `{ name: 'Vishnu' }` |
| `Array` | `[1, 2, 3]` |
| `Function` | `function() {}` |

```jsx
let arr1 = [1, 2, 3];
let arr2 = arr1;
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4] → also changed!
```

🧠 `arr1` and `arr2` point to the **same memory address** in the heap.

---

## 📊 Memory Behavior Summary

| Feature | Primitive | Reference |
| --- | --- | --- |
| Stored in | Stack | Heap + reference in stack |
| Copied by | Value | Reference (address) |
| Mutable | ❌ No | ✅ Yes |
| Comparison | By value (`===`) | By reference |

## 🧪 DSA Relevance

### ✅ Primitives

- Used in counting, comparison, and tracking state (`let max = -Infinity`)
- **Immutable** – ensures values don’t change accidentally

### ✅ Reference Types

- Arrays (core to DSA): used in stacks, queues, trees
- Objects: used in hash maps, graphs
- Functions: used as callbacks, memoization

## 🧠 Trick Interview Question

```jsx
let x = { name: "Alice" };
let y = x;
x.name = "Bob";
console.log(y.name); // ?
```

👉 Output: `"Bob"` — because `x` and `y` point to the **same object**.

## 🧠 JavaScript Memory Model (Stack vs Heap)

### 🔹 Stack Memory

- Stores **primitive values**
- Stores **references/pointers to heap objects**
- Operates in a **LIFO (Last-In-First-Out)** manner
- Fast but limited in size

### 🔹 Heap Memory

- Stores **non-primitive values** (objects, arrays, functions, etc.)
- No guaranteed order (non-linear)
- Slower access but allows dynamic allocation

## 🔍 What Happens on Declaration?

### ✅ Primitives

```jsx
let a = 42;
```

- `a` and its value `42` are stored **directly in the stack**.
- If you assign `let b = a;`, a **copy** of `42` is made — separate value.

### ✅ Reference Types (e.g., Object, Array)

```jsx
let obj = { name: "Vishnu" };
```

- `obj` (the variable itself) is stored in the **stack**
- The **actual object `{ name: "Vishnu" }`** is stored in the **heap**
- `obj` holds a **pointer (reference)** to the object in the heap

## ✅ Mutation Behavior (Very Important)

```jsx
let user = { name: "Vishnu" };
let copy = user;

copy.name = "PS";
```

- Both `user` and `copy` point to the **same object in heap**
- Changing `copy.name` updates the object in the heap — and `user` reflects it too

## ✅ Reassignment Behavior

```jsx
let user = { name: "Vishnu" };
user = { name: "PS" }; // new object
```

- A **new object** is created in the **heap**
- `user` in the **stack now points to a new memory address**
- The old heap object (if no other reference exists) is **eligible for garbage collection**

> 🔥 Garbage Collection: When no variable in the stack points to a heap object, it's considered unreachable and automatically cleaned up by the JavaScript engine.
> 

## 📦 Summary: Where Things Live

| Component | Memory | Notes |
| --- | --- | --- |
| Primitive value | Stack | Stored directly |
| Reference variable | Stack | Holds reference (address) |
| Object/Array/Function | Heap | Actual data lives here |
| Reassignment | Stack pointer | Changes to new heap address |
| Mutation | Heap | Changes the same heap object |

### 🧠 What You Said (Refined):

> In case of non-primitive variables, the actual data is stored in heap memory, and the variable stores a pointer in the stack. When we reassign the variable, a new object is created in the heap, and the stack pointer now points to the new location. If no other variable points to the old heap object, it becomes eligible for garbage collection.
> 

✅ ✅ ✅ That’s **spot on**.

## Loops

## 🔁 1. `for` Loop – Classic & Most Flexible

### 📌 Syntax:

```jsx
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

### ✅ Key Features:

- Uses **initializer, condition, increment**
- Works well with **index-based iteration**
- Can use `break`, `continue`, `return`

### 🔍 DSA Use:

Perfect for arrays, matrix traversal, binary search, etc.

## 🔁 2. `while` Loop – Condition-Driven

### 📌 Syntax:

```jsx
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
```

### ✅ Key Features:

- Runs **while the condition is true**
- Good when the **number of iterations is unknown**
- Can use `break`, `continue`

### 🔍 DSA Use:

Useful for:

- Sentinel loops (stop on `null` or `undefined`)
- BFS/DFS where condition is dynamic (e.g., queue length)

## 🔁 3. `for..of` Loop – Value-Based Iteration

### 📌 Syntax:

```jsx
const arr = [10, 20, 30];
for (const value of arr) {
  console.log(value);
}
```

### ✅ Key Features:

- Iterates over **iterable values** (arrays, strings, sets, etc.)
- Cannot access index directly (no `i`)
- Can use `break`, `continue`

### 🔍 DSA Use:

- Clean iteration when you don’t need index
- Good for looping over:
    - Arrays
    - Strings
    - Sets
    - Custom iterables

## 🔁 4. `forEach()` – Array Method Callback

### 📌 Syntax:

```jsx
[1, 2, 3].forEach((value, index, array) => {
  console.log(value, index);
});
```

### ✅ Key Features:

- Calls a function **once per element**
- Cannot use `break`, `continue`, or `return` (control flow is limited)
- Synchronous

### 🔍 DSA Use:

❌ Not ideal for control-heavy logic (like early exit or skipping)

✅ Fine for:

- Mapping values
- Logging or shallow iteration

## 📊 Comparison Table

| Loop | Best For | Can Use `break`/`continue` | Index Access | DSA Friendly |
| --- | --- | --- | --- | --- |
| `for` | Index-based, full control | ✅ Yes | ✅ Yes | ✅✅✅ |
| `while` | Unknown length, dynamic stop | ✅ Yes | ✅ (manually) | ✅✅✅ |
| `for..of` | Value-based iteration | ✅ Yes | ❌ No | ✅✅ |
| `forEach` | Array traversal with callback | ❌ No | ✅ Yes | ❌ (limited) |

## ⚠️ Gotchas

### ❌ `forEach` vs `async/await`:

```jsx
arr.forEach(async (item) => {
  await doSomething(item); // ❌ Doesn’t wait
});
```

Use `for..of` with `await` instead.

## 🧠 Instructor Tip

> Use for or while for DSA problems where control flow matters (like early exits, skipping, reverse traversal).
> 
> 
> Use `for..of` for clean iterable access.
> 
> Avoid `forEach` for anything control-sensitive.
> 

## 🧠 1. Function Declaration

### ✅ Syntax:

```jsx
function greet(name) {
  return `Hello, ${name}`;
}
```

### 📌 Key Traits:

| Feature | Behavior |
| --- | --- |
| Hoisted | ✅ Yes — accessible before definition |
| `this` binding | Dynamic (`this` depends on caller) |
| Named | ✅ Yes |

### 🔍 Use Case:

- Traditional functions
- Utility functions
- Good for **DSA problems** (e.g., recursion, helper functions)

### 🔁 DSA Example:

```jsx
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}
```

## 🧠 2. Function Expression

### ✅ Syntax:

```jsx
const greet = function(name) {
  return `Hi, ${name}`;
};
```

### 📌 Key Traits:

| Feature | Behavior |
| --- | --- |
| Hoisted | ❌ No — only after definition |
| `this` binding | Dynamic (`this` depends on caller) |
| Anonymous/named | Can be anonymous or named |

### 🔍 Use Case:

- When you want to assign a function to a variable
- Pass as a callback
- Maintain closures

### 🔁 DSA Use:

Useful when returning or passing functions dynamically:

```jsx
function executor(fn) {
  return fn(10);
}

const square = function(n) {
  return n * n;
};

console.log(executor(square)); // 100
```

## 🧠 3. Arrow Function

### ✅ Syntax:

```jsx
const greet = (name) => `Hey, ${name}`;
```

### 📌 Key Traits:

| Feature | Behavior |
| --- | --- |
| Hoisted | ❌ No |
| `this` binding | ❌ Lexical (from surrounding scope) |
| Shorter syntax | ✅ Yes |
| `arguments` | ❌ Not available |

### 🔍 Use Case:

- Inline functions
- Functional programming
- Avoiding `this` confusion in callbacks (e.g., React, setTimeout)

### ⚠️ DSA Tip:

Avoid arrow functions for **recursive logic** or **methods needing `this`**

```jsx
const fib = (n) => { // ✅ works for recursion
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
};
```

But for methods:

```jsx
const obj = {
  count: 0,
  increment: () => {
    this.count++; // ❌ `this` is undefined
  },
};
```

## 🧪 Comparison Table

| Feature | Declaration | Expression | Arrow Function |
| --- | --- | --- | --- |
| Hoisted | ✅ Yes | ❌ No | ❌ No |
| `this` binding | Dynamic | Dynamic | Lexical (outer scope) |
| Syntax | Verbose | Medium | Concise |
| Used for recursion | ✅ Best choice | ✅ Yes | ✅ (but not for methods) |
| Used in methods | ✅ Yes | ✅ Yes | ❌ No |
| Access `arguments` | ✅ Yes | ✅ Yes | ❌ No |

# 🌀 **Recursion + Call Stack in JavaScript**

## 🔁 1. What is Recursion?

> A function calling itself until it reaches a base case.
> 

### 📌 Structure:

```jsx
function recurse(params) {
  if (baseCase) return;
  // work
  recurse(smallerProblem);
}
```

### ✅ Key Ingredients:

- **Base Case:** Condition to stop recursion
- **Recursive Case:** Function calls itself with modified input

### 🔧 Example: Factorial

```jsx
function factorial(n) {
  if (n === 0) return 1;           // Base case
  return n * factorial(n - 1);     // Recursive case
}

factorial(4); // 4 * 3 * 2 * 1 = 24
```

## 🧠 2. Call Stack – How Recursion Works Internally

### 📚 What is the Call Stack?

> The call stack is a LIFO (Last In, First Out) structure used by JS to keep track of function calls.
> 

Each time a function is called:

1. A new **execution context** is pushed onto the call stack.
2. When the function returns, its context is **popped off**.

### 🔍 What Happens in `factorial(4)`?

Call stack grows like this:

```scss
factorial(4) → 4 * factorial(3)
factorial(3) → 3 * factorial(2)
factorial(2) → 2 * factorial(1)
factorial(1) → 1 * factorial(0)
factorial(0) → 1  ← base case hit
```

Now it *unwinds*:

```jsx
matlab
Copy code
factorial(1) = 1 * 1 = 1
factorial(2) = 2 * 1 = 2
factorial(3) = 3 * 2 = 6
factorial(4) = 4 * 6 = 24
```

### 📦 Stack Snapshot (During `factorial(4)`)

| Step | Stack Top → Bottom |
| --- | --- |
| Before start |  |
| Call 4 | `factorial(4)` |
| Call 3 | `factorial(3)` |
| Call 2 | `factorial(2)` |
| Call 1 | `factorial(1)` |
| Call 0 | `factorial(0)` (returns 1) |

Then it starts popping...

## ⚠️ Stack Overflow

```jsx
\function infiniteRecursion() {
  return infiniteRecursion();
}
infiniteRecursion(); // ❌ Maximum call stack size exceeded
```

> 💥 Recursive calls must have a base case — otherwise, the stack keeps growing until memory runs out.
> 

## 📊 Recursion vs Loop (DSA Context)

| Feature | Recursion | Loop |
| --- | --- | --- |
| Code readability | Cleaner for tree/graph/DFS | Cleaner for simple counting |
| Stack usage | Uses call stack | No stack overhead |
| Performance | Slower due to call overhead | Generally faster |
| Tail call optimization | ❌ Not guaranteed in JS | N/A |

## 🧠 Instructor Tip:

> Teach recursion by visualizing the call stack growth and shrink — use stack diagrams and always define base cases first.
> 

### ✅ Classic Recursion DSA Examples:

| Problem | Base Case Example |
| --- | --- |
| Factorial | `n === 0` |
| Fibonacci | `n === 0 |
| Reverse string | `str === ""` |
| Binary search | `low > high` |
| DFS / Backtrack | `node is null or visited` |

# [Recursion Practical Questions](https://www.notion.so/Recursion-Practical-Questions-2199b780968d803dbf60cbf96de26ef2?pvs=21)

# Arrays

# Strings

# Stack

Linear data structure that follows the LIFO principle

Last In First Out

### 🧠 **Key Operations**

| Operation | Description | JavaScript Equivalent |
| --- | --- | --- |
| `push(x)` | Add an item to the top | `arr.push(x)` |
| `pop()` | Remove the top item | `arr.pop()` |
| `peek()` | Look at the top item (no remove) | `arr[arr.length - 1]` |
| `isEmpty()` | Check if the stack is empty | `arr.length === 0` |

### **Common Use Cases**

- Undo/redo systems
- Function call stacks in recursion
- Parentheses validation
- Infix → Postfix expression conversion
- Depth-first search (DFS)
- Backtracking (like Sudoku, N-Queens)

# Stack Implementations

## Using JavaScript Array & Using ES6 Class

```jsx

```

## Custom implementation using Linked List (advanced)

```jsx
// Node class
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

// Stack class using Linked List
class Stack {
  constructor() {
    this.top = null;
    this.size = 0;
  }

  // Push to top
  push(data) {
    const newNode = new Node(data);
    newNode.next = this.top;
    this.top = newNode;
    this.size++;
  }

  // Pop from top
  pop() {
    if (this.isEmpty()) {
      return "Stack Underflow";
    }
    const popped = this.top.data;
    this.top = this.top.next;
    this.size--;
    return popped;
  }

  // Peek at top element
  peek() {
    if (this.isEmpty()) return null;
    return this.top.data;
  }

  // Check if empty
  isEmpty() {
    return this.top === null;
  }

  // Print the stack (top to bottom)
  print() {
    let current = this.top;
    let result = "";
    while (current) {
      result += current.data + " -> ";
      current = current.next;
    }
    console.log(result + "null");
  }
}
const stack = new Stack();

stack.push(10);
stack.push(20);
stack.push(30);

stack.print();         // 30 -> 20 -> 10 -> null
console.log(stack.pop());  // 30
console.log(stack.peek()); // 20
console.log(stack.isEmpty()); // false
```

## Using Queue

```jsx
class StackUsingQueue{
    constructor() {
        this.queue = [];

    }
    push(x){
        const size = this.queue.length;
        this.queue.push(x);
        for(let i = 0; i <size; i++){
            this.queue.push(this.queue.shift());
        }
    }
    pop(){
        if(this.isEmpty()){
            return "Underflow"
        }
        return this.queue.shift()

    }
    top(){
        return this.isEmpty()? null: this.queue[0];

    }
    isEmpty(){
        return this.queue.length=== 0;

    }
    size(){
        return this.queue.length;

    }
    print(){
        console.log('Top->', this.queue.join('<-'), '<-Bottom');
    }
}
const stack = new StackUsingQueue();

stack.push(10);
stack.push(20);
stack.push(30);

stack.print();        // Top -> 30 <- 20 <- 10 <- Bottom

console.log(stack.pop()); // 30
console.log(stack.top()); // 20
stack.print();        // Top -> 20 <- 10 <- Bottom
```

# Queue

## 🚌 **What is a Queue?**

A **Queue** is a **linear data structure** that follows the **FIFO** principle:

> 🔁 First In, First Out
> 
> 
> The **first** element added is the **first** to be removed — just like people standing in line for a bus.
> 

### 📦 Real-life Analogies

- **Printer queue** — first job gets printed first.
- **Customer service line**
- **Call center queue**
- **Task scheduling**

## 🧠 Core Operations

| Operation | Description | JavaScript Equivalent |
| --- | --- | --- |
| `enqueue(x)` | Add element to the **rear** | `array.push(x)` |
| `dequeue()` | Remove element from the **front** | `array.shift()` |
| `peek()` | View the front element | `array[0]` |
| `isEmpty()` | Check if the queue is empty | `arr.length === 0` |
| `size()` | Return number of elements | `arr.length` |

## Applications of Queue

| Use Case | Description |
| --- | --- |
| 🌐 Web server requests | Handle client requests FIFO |
| 🧾 Print queues | Process print jobs in order |
| 🏁 BFS traversal (Graphs/Trees) | Level-wise traversal |
| ⏳ CPU task scheduling | Round-robin or fair scheduling |
| 🔀 Caching (LRU) | Use Queue + HashMap |

# Queue Implementations

## Using JavaScript Array (with `push` & `shift`) & Using ES6 Class

```jsx
class Queue {
  constructor() {
    this.items = [];
  }

  // Add item to the rear (enqueue)
  enqueue(element) {
    this.items.push(element); // O(1)
  }

  // Remove item from the front (dequeue)
  dequeue() {
    if (this.isEmpty()) return "Underflow";
    return this.items.shift(); // O(n) — shift moves all elements
  }

  // Peek at the front item
  peek() {
    if (this.isEmpty()) return null;
    return this.items[0];
  }

  // Check if queue is empty
  isEmpty() {
    return this.items.length === 0;
  }

  // Return queue size
  size() {
    return this.items.length;
  }

  // Print queue elements
  print() {
    console.log(this.items.join(" <- "));
  }
}
const queue = new Queue();

queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);

queue.print();         // 10 <- 20 <- 30

console.log(queue.dequeue()); // 10
console.log(queue.peek());    // 20
console.log(queue.isEmpty()); // false

queue.print();         // 20 <- 30
```

## Using Linked List (more efficient `O(1)` enqueue/dequeue)

```jsx
// Node class
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

// Queue using Linked List
class Queue {
  constructor() {
    this.front = null;
    this.rear = null;
    this.length = 0;
  }

  // Enqueue (add to rear)
  enqueue(data) {
    const newNode = new Node(data);
    if (!this.front) {
      this.front = this.rear = newNode;
    } else {
      this.rear.next = newNode;
      this.rear = newNode;
    }
    this.length++;
  }

  // Dequeue (remove from front)
  dequeue() {
    if (!this.front) return "Queue is empty";

    const removed = this.front.data;
    this.front = this.front.next;
    if (!this.front) this.rear = null; // Queue became empty
    this.length--;
    return removed;
  }

  // Peek at front
  peek() {
    return this.front ? this.front.data : null;
  }

  // Check if empty
  isEmpty() {
    return this.length === 0;
  }

  // Get size
  size() {
    return this.length;
  }

  // Print queue
  print() {
    let curr = this.front;
    let result = "Front -> ";
    while (curr) {
      result += curr.data + " <- ";
      curr = curr.next;
    }
    result += "Rear";
    console.log(result);
  }
}
const q = new Queue();

q.enqueue("vishnu");
q.enqueue("priya");
q.enqueue("arun");

q.print();              // Front -> vishnu <- priya <- arun <- Rear
console.log(q.dequeue()); // vishnu
console.log(q.peek());    // priya
q.print();              // Front -> priya <- arun <- Rear
```

## Queue using Two Stacks (interview classic)

### ✅ Approach: Two Stacks

Let’s name the two stacks:

- `stack1` → Used for **enqueue** (pushing new elements)
- `stack2` → Used for **dequeue** (reverses the order for FIFO)

### 🔁 Logic:

### **enqueue(x)**:

- Just push `x` to `stack1`

### **dequeue()**:

- If `stack2` is empty:
    - Pop all items from `stack1` and push to `stack2`
- Then pop from `stack2`

This way, the oldest element in `stack1` becomes the top of `stack2`, mimicking queue behavior.

```jsx
class QueueUsingStack {
  constructor() {
    this.stack1 = []; // main input stack
    this.stack2 = []; // output stack
  }

  // Enqueue: O(1)
  enqueue(x) {
    this.stack1.push(x);
  }

  // Dequeue: Amortized O(1), worst O(n)
  dequeue() {
    if (this.isEmpty()) return "Queue is empty";

    // Move elements only if stack2 is empty
    if (this.stack2.length === 0) {
      while (this.stack1.length > 0) {
        this.stack2.push(this.stack1.pop());
      }
    }

    return this.stack2.pop();
  }

  // Peek at front element
  peek() {
    if (this.isEmpty()) return null;

    if (this.stack2.length === 0) {
      while (this.stack1.length > 0) {
        this.stack2.push(this.stack1.pop());
      }
    }

    return this.stack2[this.stack2.length - 1];
  }

  // Check if empty
  isEmpty() {
    return this.stack1.length === 0 && this.stack2.length === 0;
  }

  // Size
  size() {
    return this.stack1.length + this.stack2.length;
  }

  // Print current queue state
  print() {
    const s2 = [...this.stack2].reverse(); // already in queue order
    const s1 = [...this.stack1];           // needs to be appended
    console.log("Front ->", [...s2, ...s1].join(" <- "), "<- Rear");
  }
}
const q = new QueueUsingStack();

q.enqueue("vishnu");
q.enqueue("arun");
q.enqueue("priya");

q.print();              // Front -> vishnu <- arun <- priya <- Rear
console.log(q.dequeue()); // vishnu
console.log(q.peek());    // arun
q.print();              // Front -> arun <- priya <- Rear

```

### Queue i Circular Array (Circular Queue)

## **What is a Circular Queue?**

In a **circular queue**, the rear pointer wraps around to the beginning of the queue when the queue is full and space becomes available. This ensures efficient utilization of space.

### 🧠 Key Concept:

- Once the rear reaches the end of the array, it loops back to the beginning (if there's space).
- It ensures that space isn’t wasted when elements are dequeued.

### 🛠️ **Circular Queue Characteristics:**

1. **Fixed size:** A circular queue is implemented with a **fixed size array**.
2. **Wrap-around:** When the **rear** reaches the last position, it **wraps around** to the front if there is space available.

## ✅ **Circular Queue Operations:**

- **enqueue(x):** Add an element to the rear of the queue.
- **dequeue():** Remove an element from the front of the queue.
- **isFull():** Check if the queue is full.
- **isEmpty():** Check if the queue is empty.
- **peek():** View the front element without removing it.
- **size():** Get the number of elements in the queue.

## ✅ **Implementation of Circular Queue**

### 📦 **Code: Circular Queue (Using ES6 Class)**

```jsx
class CircularQueue {
  constructor(size) {
    this.size = size;      // Maximum size of the queue
    this.queue = new Array(size);
    this.front = -1;        // Points to the front of the queue
    this.rear = -1;         // Points to the rear of the queue
  }

  // Enqueue: Add element at the rear
  enqueue(value) {
    if (this.isFull()) {
      console.log("Queue is full");
      return;
    }

    if (this.front === -1) {
      this.front = 0; // Queue is empty
    }

    this.rear = (this.rear + 1) % this.size;  // Circular wrap-around
    this.queue[this.rear] = value;
    console.log(`${value} added to queue`);
  }

  // Dequeue: Remove element from the front
  dequeue() {
    if (this.isEmpty()) {
      console.log("Queue is empty");
      return;
    }

    const dequeued = this.queue[this.front];
    if (this.front === this.rear) {
      this.front = this.rear = -1; // Queue is empty
    } else {
      this.front = (this.front + 1) % this.size;  // Circular wrap-around
    }
    console.log(`${dequeued} removed from queue`);
    return dequeued;
  }

  // Peek: Get the front element
  peek() {
    if (this.isEmpty()) {
      console.log("Queue is empty");
      return;
    }
    console.log(`Front element is: ${this.queue[this.front]}`);
    return this.queue[this.front];
  }

  // Check if the queue is empty
  isEmpty() {
    return this.front === -1;
  }

  // Check if the queue is full
  isFull() {
    return (this.rear + 1) % this.size === this.front;
  }

  // Get the size of the queue
  sizeOfQueue() {
    if (this.isEmpty()) return 0;
    return (this.rear - this.front + 1 + this.size) % this.size;
  }

  // Print the queue
  printQueue() {
    if (this.isEmpty()) {
      console.log("Queue is empty");
      return;
    }

    let i = this.front;
    while (i !== this.rear) {
      process.stdout.write(this.queue[i] + " <- ");
      i = (i + 1) % this.size;
    }
    console.log(this.queue[this.rear]);
  }
}
```

### 🧪 **Test the Circular Queue**

```jsx
const queue = new CircularQueue(5);  // Queue size is 5

queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
queue.enqueue(40);
queue.enqueue(50);

queue.printQueue();  // Output: 10 <- 20 <- 30 <- 40 <- 50

queue.dequeue();     // Output: 10 removed from queue
queue.dequeue();     // Output: 20 removed from queue

queue.enqueue(60);   // Output: 60 added to queue

queue.printQueue();  // Output: 30 <- 40 <- 50 <- 60

queue.peek();        // Output: Front element is: 30
console.log(queue.sizeOfQueue());  // Output: 4
```

### 🧠 **Key Concepts:**

1. **Array as fixed-size storage:** The queue is implemented using a fixed-size array (`queue[]`).
2. **Front and rear pointers:** `front` indicates the first item, and `rear` points to the last item.
3. **Wrap-around:** Both `enqueue()` and `dequeue()` make use of modulo operations (`% size`) to implement the circular behavior.

### ⏱️ **Time Complexity:**

| Operation | Time Complexity |
| --- | --- |
| `enqueue()` | O(1) |
| `dequeue()` | O(1) |
| `peek()` | O(1) |
| `isEmpty()` | O(1) |
| `isFull()` | O(1) |

### 🔧 **Real-world Applications of Circular Queue:**

- **Buffer Management:** In systems like data streaming (e.g., network buffering).
- **CPU Scheduling:** Round-robin scheduling algorithms.
- **Traffic Management:** Managing vehicles in a fixed-length traffic queue.

# **Types of Queues** — with Full DSA Context

### 1️⃣ **Simple Queue**

> 🔁 FIFO: First In First Out — standard queue behavior.
> 

### 📦 Operations

- `enqueue(x)` → rear
- `dequeue()` → front

### ✅ Use Cases:

- Print queue
- CPU task scheduling
- Web request queue

### 🧠 Implementation:

- Array or Linked List

### 2️⃣ **Circular Queue**

> 🔄 A queue that wraps around when the rear reaches the end of the array.
> 

### 📦 Behavior:

- Fixed-size buffer
- `rear = (rear + 1) % size`

### ✅ Use Cases:

- Circular buffers in audio/video streams
- OS-level scheduling
- Traffic systems

### 🛠️ Implementation:

- Fixed array + modulo index handling

### 3️⃣ **Deque** (Double Ended Queue)

> 🔁 Queue where insertion and deletion can happen from both ends
> 

| Operation | Front | Rear |
| --- | --- | --- |
| Enqueue | ✅ | ✅ |
| Dequeue | ✅ | ✅ |

### ✅ Use Cases:

- **Palindrome checking**
- **Sliding Window Maximum** (Monotonic Queue builds on this)
- Undo/Redo operations (like browser history)

### 🛠️ Implementation:

- JavaScript: use `push`, `pop`, `shift`, `unshift`

```jsx

```

- Deque class with two-ended support

```jsx

```

### 4️⃣ **Priority Queue / Min-Max Heap**

> 🎯 Each element has a priority, and the element with the highest or lowest priority is dequeued first.
> 

### 📦 Behavior:

- Elements are **ordered by priority**, not just insertion time.

### ✅ Use Cases:

- Dijkstra’s Algorithm
- Task scheduling
- AI (A* search)
- OS process handling

### 🛠️ Implementation:

- Use **Binary Heap** (Min Heap / Max Heap)

```jsx

```

- Or JavaScript array + custom sort (less efficient)

```jsx

```

### 5️⃣ **Monotonic Queue**

> 📉 A deque that keeps elements in increasing or decreasing order — used in problems like Sliding Window Maximum
> 

### 🧠 Behavior:

- Elements are pushed while maintaining a **monotonic** (increasing/decreasing) sequence
- When a new element breaks the sequence, you remove elements from the back

### ✅ Use Cases:

- **Sliding Window Max/Min**
- Maximum of last K elements
- Optimized greedy algorithms

### 🛠️ Implementation:

- Built on top of **Deque**

```jsx

```

- Maintains a strictly ordered window

```jsx

```

## 🔄 Summary Table

| Type | Supports Both Ends? | Priority? | Circular? | Use Case Example |
| --- | --- | --- | --- | --- |
| Simple Queue | No | No | No | Printer, customer service |
| Circular Queue | No | No | ✅ | Audio buffers, OS scheduling |
| Deque | ✅ | No | Optional | Palindromes, undo/redo |
| Priority Queue | No | ✅ | No | Dijkstra, CPU scheduling |
| Monotonic Queue | ✅ | No | No | Sliding window problems |

## ✅ Suggested Implementation Practice Flow

| Da | Queue Type | Task |
| --- | --- | --- |
| 1 | Simple Queue | Build with array & linked list |
| 2 | Circular Queue | Implement fixed-size queue |
| 3 | Deque | Build and test all 4 operations |
| 4 | Priority Queue | Use min-heap or sort method |
| 5 | Monotonic Queue | Solve sliding window max/min |

## Exercise: Reverse a Queue Using recursion

```jsx
function reverseQueue(queue) {
  if (queue.length === 0) return;

  // Dequeue front item
  let front = queue.shift();

  // Recursively reverse remaining queue
  reverseQueue(queue);

  // Enqueue the front item at the end
  queue.push(front);
}
let queue = [10, 20, 30, 40];
reverseQueue(queue);
console.log(queue); // [40, 30, 20, 10]
```

# Linked List

## 🧠 **What is a Linked List?**

A **Linked List** is a **linear data structure** where elements (called **nodes**) are stored in **separate objects**, and each node points to the **next** node in the sequence.

Unlike arrays, **linked lists do not store elements in contiguous memory** — instead, each node contains:

1. **Data** (the actual value)
2. **Pointer** (reference to the next node)

### 📦 Node Structure (Singly Linked List):

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
```

### 🔗 Structure Visualization:

```
[10 | next] → [20 | next] → [30 | null]
```

- `10`, `20`, `30` are node values.
- `next` is a pointer/reference to the next node.
- The last node’s `next` is `null`.

## 📦 Real-World Analogy

Imagine a **treasure map** where each clue contains:

- A **message** (data)
- A **pointer** to the next clue (next)

You **can only follow one clue at a time**, not skip to the 5th directly like an array.

## 🔁 Key Characteristics

| Feature | Description |
| --- | --- |
| Dynamic Size | Can grow/shrink at runtime (no resizing) |
| No random access | Can’t access via index — must traverse |
| Insert/Delete is fast | Especially at head/tail (O(1)) |
| Memory non-contiguous | Nodes can be scattered in memory |

## 📊 Array vs Linked List

| Feature | Array | Linked List |
| --- | --- | --- |
| Memory | Contiguous | Non-contiguous |
| Access | O(1) via index | O(n) (must traverse) |
| Insert/Delete | Expensive (shift) | Cheap at head/tail |
| Size | Fixed/Resized | Dynamic |

## ✅ When to Use Linked Lists:

- When **insertions and deletions** are frequent
- When you're building **stacks**, **queues**, or **dynamic memory** structures
- When you don’t need **random access**

## Doubly Linked List

## 📚 What is a Doubly Linked List?

A **Doubly Linked List (DLL)** is a linear data structure consisting of **nodes**, where **each node contains three parts**:

```css
[ prev | data | next ]
```

- `data`: The value stored
- `prev`: Pointer to the **previous node**
- `next`: Pointer to the **next node**

Each node knows **who comes before and after it**.

## 🔗 Visual Representation

Example: List containing `10 → 20 → 30`

```css
null ← [10] ⇄ [20] ⇄ [30] → null
```

- `10.prev = null`, `10.next = 20`
- `20.prev = 10`, `20.next = 30`
- `30.prev = 20`, `30.next = null`

## 🔁 How It Differs from Singly Linked List (SLL)

| Feature | Singly Linked List | Doubly Linked List |
| --- | --- | --- |
| Navigation | One direction (→) | Two directions (←, →) |
| Memory usage | Less (1 pointer) | More (2 pointers) |
| Reverse traversal | ❌ Not easy | ✅ Simple |
| Insertion/deletion | Hard before node | Easy (with prev pointer) |

## 🔧 Operations on DLL

### 1. **Insertion**

- At head
- At tail
- At specific position
- In sorted order

### 2. **Deletion**

- From head
- From tail
- At specific index
- By value

### 3. **Traversal**

- Forward (start → end)
- Backward (end → start)

## 🧠 Advantages

- You can move **both forward and backward** through the list.
- Deleting a node is easier (no need to keep track of the previous one).
- It's great for apps like **undo-redo**, **browser history**, **music playlist navigation**, etc.

## ⚠️ Disadvantages

- Slightly more complex to implement.
- Uses **extra memory** for the `prev` pointer.
- More care needed while updating both `next` and `prev`.

## 📦 Real-World Applications

- **Undo/Redo systems** (e.g., Ctrl+Z, Ctrl+Y)
- **Web browser history**
- **MRU/LRU Caches** (e.g., in OS, memory paging)
- **Music/Media players** (next/prev song)

## 🏗️ Node Structure (in JS)

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }
}
```

## 🧠 Key Concepts to Master

| Concept | Must Understand? |
| --- | --- |
| Pointer rewiring | ✅ Yes |
| Head/tail edge cases | ✅ Yes |
| Traversals | ✅ Yes |
| Insert/delete at pos | ✅ Yes |
| Memory cleanup (GC) | Optional |

```jsx
class Node{
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
    }
    insertAtBeginning(data){
        const newNode = new Node(data);
        if(!this.head) {
            this.head= this.tail = newNode;
        } else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
    }
    insertAtTail(data){
        const newNode = new Node(data);
        if(!this.tail) {
            this.tail = this.head = newNode;
        } else {
            this.tail.next = newNode;
            newNode.prev = this.tail;
            this.tail = newNode;
        }
    }
    insertAtPosition(data, index) {
        if (index < 0) return;
      
        if (!this.head|| index === 0) return this.insertAtBeginning(data);
      
        let current = this.head;
        let count = 0;
      
        while (current && count < index) {
          current = current.next;
          count++;
        }
      
        if (!current) return this.insertAtTail(data); // out of bounds
      
        const newNode = new Node(data);
        newNode.prev = current.prev;
        newNode.next = current;
      
        current.prev.next = newNode; // ✅ guaranteed to exist
        current.prev = newNode;
      }
      
    deleteFromHead(){
        if(!this.head) return;
        if(this.head === this.tail) {
            this.head= this.tail = null;
        } else {
        this.head = this.head.next;
        this.head.prev = null;

        }
    }
    deleteFromTail(){
        if(!this.head) return;
        if(this.head === this.tail){
            this.head = this.tail = null;
        } else {
            this.tail = this.tail.prev;
            this.tail.next = null;
        } 
    }
    deleteAtPostion(index){
        if(index<0) return "The position is out of bounds";
        if(index ===0) return this.deleteFromHead();
        let current = this.head;
        let count = 0;
        while(current && count < index){
            current = current.next;
            count ++;
        }
        if(!current) return console.log(" Index is out of bounds");
        if(current.prev) current.prev.next = current.next;
        if(current.next) current.next.prev = current.prev;
        if(current === this.tail) this.tail = current.prev;
    }
    traverseForward(){
        let current = this.head
        let result = "head->";
        while(current) {
            result+=current.data + '<->';
            current = current.next;
        }
        console.log(result + "null")
    }
    traverseBackward(){
        let current  = this.tail;
        let result = 'tail->';
        while (current) {
            result += current.data +'<->';
            current = current.prev;
        }
        console.log(result+'null');
    }
    reverse() {
        let curr = this.head;
        let temp = null;
    
        while (curr) {
          // Swap prev and next
          temp = curr.prev;
          curr.prev = curr.next;
          curr.next = temp;
    
          // Move to next (which is prev now)
          curr = curr.prev;
        }
    
        // After full reversal, swap head and tail
        if (temp) {
          this.head = temp.prev;
        }
      }
    }

    const dll = new DoublyLinkedList();

dll.insertAtBeginning(10);
dll.insertAtTail(20);
dll.insertAtTail(30);
dll.insertAtPosition(15, 1);

dll.traverseForward();   // Head -> 10 <-> 15 <-> 20 <-> 30 <-> null
dll.traverseBackward();  // Tail -> 30 <-> 20 <-> 15 <-> 10 <-> null

dll.deleteFromHead();
dll.deleteFromTail();
dll.deleteAtPostion(1);

dll.traverseForward();   // Head -> 15 <-> null

dll.reverse();
dll.traverseForward();   // Head -> 15 <-> null

```

# Hashing

## 📚 What is Hashing in DSA?

**Hashing** is a technique to **map data to a fixed-size value** (called a *hash*) using a **hash function**. This value (or key) is then used to **index into a data structure** like an array or object.

> In simpler terms: it gives you almost instant access to data — often in O(1) time!
> 

## 🧠 Real-World Analogy

Imagine a **library**:

- Book titles are stored in a giant shelf.
- Instead of checking each book linearly, you use an **index (hash)** that tells you exactly where the book is placed.

Hashing = Jump directly to where the data is.

## 🔧 Hash Function

A **hash function** takes a key and produces a hash (usually a number):

```jsx
js
Copy code
hash("vishnu") => 47
```

You use this hash to store data in an array at index 47.

## 📦 Common Hashing Use-Cases

| Use Case | Structure |
| --- | --- |
| Fast lookup / search | Hash table / map |
| Frequency counter | Object / Map |
| Caching | Map |
| Detect duplicates | Set |
| Anagram problems | Char map |
| LRU Cache, DB Indexing | Custom hash maps |

## 🛠️ Data Structures Using Hashing

| DS | Description |
| --- | --- |
| **Hash Table** | Maps keys to values using hash functions |
| **Hash Map** | Key-value store, dynamic sizing |
| **Hash Set** | Stores only keys, no values, no duplicates |

### In JS:

- `Object` or `Map` → Hash Map
- `Set` → Hash Set

## 🔐 Ideal Hash Function Properties

- **Fast to compute**
- **Minimizes collisions** (different keys giving same hash)
- **Uniform distribution** (spread out over array)
- **Deterministic** (same input → same output)

## ⚔️ What Are Collisions?

When two keys map to the same index:

```jsx
hash("bat") → 5
hash("tab") → 5   // collision
```

Handled by:

- **Chaining** (store values in a linked list at that index)
- **Open Addressing** (find next empty spot)

## ⏱️ Time Complexities (Ideal Case)

| Operation | Time Complexity |
| --- | --- |
| Insert | O(1) |
| Search | O(1) |
| Delete | O(1) |

⚠️ In worst-case (bad hash + collisions) → becomes **O(n)**

## 🧪 Example Problems Using Hashing

| Problem Type | Key Idea |
| --- | --- |
| Two Sum / Pair Sum | Store values in map and lookup |
| Count frequencies | Use hash map |
| Check if two strings are anagrams | Sort + map char frequency |
| Longest Consecutive Sequence | Use Set for O(1) checks |
| Subarray with sum 0 / k | Prefix sum + map |
| First non-repeating character | Map + index tracking |

## 💻 JS Code Example: Frequency Counter

```jsx
function countFreq(arr) {
  const map = new Map();

  for (let num of arr) {
    map.set(num, (map.get(num) || 0) + 1);
  }

  return map;
}
```

## Differences between Object, Map, WeakMap, Set, WeakSet

## 🧩 1. **Object vs Map**

| Feature | `Object` | `Map` |
| --- | --- | --- |
| Key types | Only `string` or `symbol` | **Any type** (object, number, function...) |
| Key order | Not guaranteed (until ES6) | **Insertion order preserved** |
| Size property | ❌ No built-in `.size` | ✅ `.size` exists |
| Performance | Slower for frequent inserts/deletes | Optimized for key-value operations |
| Iteration | `for...in`, `Object.keys()` | `map.forEach()`, `for...of`, `entries()` |
| Intended for | General data structures | **Key-value maps** |
| Inheritance | Inherits from `Object.prototype` | No prototype pollution |
| Use case | Basic structure (non-hash use) | **When using as a hash map** |

## 🔐 2. **Map vs WeakMap**

| Feature | `Map` | `WeakMap` |
| --- | --- | --- |
| Key types | Any (primitives & objects) | Only **objects** as keys |
| Key reference | Strong | **Weak** — no ref prevents GC |
| GC behavior | Not garbage collected | If key object is deleted → entry is gone |
| Iteration | ✅ Iterable (`forEach`, `for..of`) | ❌ Not iterable |
| Use case | Normal key-value store | **Private object metadata**, memory-safe |

> 🧠 Use WeakMap when you want to associate data with an object without preventing its garbage collection.
> 

## 📦 3. **Set vs WeakSet**

| Feature | `Set` | `WeakSet` |
| --- | --- | --- |
| Value types | Any (primitive or object) | Only **objects** |
| Duplicates allowed? | ❌ No — only unique values | ❌ No — same |
| Iteration | ✅ Yes (`for..of`, `.forEach`) | ❌ No |
| GC behavior | Strong references | Weak — object can be garbage collected |
| Use case | Unique collection | **Temporary object tracking** (DOM refs, caches) |

## 💡 When to Use What?

| Use Case | Use |
| --- | --- |
| Lookup by string/primitive key | `Map` or `Object` |
| Lookup by object key | `Map`, or `WeakMap` if GC-safe |
| Need insertion order | `Map`, `Set` |
| Track unique primitives | `Set` |
| Track objects without preventing GC | `WeakMap`, `WeakSet` |
| Avoid prototype pollution | `Map`, `Set` |

## 📌 Summary Table

| Feature | `Object` | `Map` | `WeakMap` | `Set` | `WeakSet` |
| --- | --- | --- | --- | --- | --- |
| Stores key-value? | ✅ | ✅ | ✅ | ❌ | ❌ |
| Stores only keys? | ❌ | ❌ | ❌ | ✅ | ✅ |
| Keys can be object? | ❌ | ✅ | ✅ | ✅ (values) | ✅ |
| Keys are GC-safe? | ❌ | ❌ | ✅ | ❌ | ✅ |
| Iterable? | ✅ | ✅ | ❌ | ✅ | ❌ |
| Maintains order? | ❌ | ✅ | ❌ | ✅ | ❌ |

## Hash Table

## 🔷 What is a Hash Table?

A **Hash Table** (aka Hash Map) is a **data structure** that stores **key-value pairs**, where:

- A **hash function** maps keys to **indices in an array**
- Values are stored at those array indices for **fast retrieval**

Think of it like a smart array that **knows where to put things based on their key**.

### 📦 Example:

```jsx
table.set("name", "Vishnu");
table.get("name"); // "Vishnu"
```

Behind the scenes:

```jsx
hash("name") = 42 → table[42] = "Vishnu"
```

## ⚙️ How It Works (Under the Hood)

1. **Hash Function**:
    
    Converts the key (like `"name"`) into a numeric index (like `42`)
    
2. **Array Storage**:
    
    The hash is used as the index into an internal array.
    
3. **Handling Collisions**:
    
    If two keys hash to the same index:
    
    - **Chaining**: Store multiple entries in a list at that index
    - **Open Addressing**: Find next available index

## 🧠 Why Is Hash Table Powerful?

| Operation | Average Time | Worst Case |
| --- | --- | --- |
| Insert | O(1) | O(n) |
| Search | O(1) | O(n) |
| Delete | O(1) | O(n) |

**In practice**, with a good hash function, we almost always get **O(1)** performance.

## 🔁 Hash Table in JavaScript

### ✅ Using a `Map`:

```jsx
const map = new Map();

map.set("a", 10);
map.set("b", 20);

console.log(map.get("a")); // 10
map.delete("b");
```

### ✅ Using an `Object` (classic way):

```jsx
const obj = {};

obj["x"] = 100;
console.log(obj["x"]); // 100
```

## 🔐 Key Characteristics

| Feature | Hash Table Behavior |
| --- | --- |
| Key uniqueness | Only one value per unique key |
| Fast access | Uses computed index |
| Collision handling | Chaining / Open Addressing |
| Key type (JS) | `Map`: Any type; `Object`: string/symbol only |

## 🧪 Simple Custom Hash Table (Instructor-Level Demo)

```jsx
class HashTable {
  constructor(size = 53) {
    this.table = new Array(size);
  }

  _hash(key) {
    let hash = 0;
    for (let char of key) {
      hash = (hash + char.charCodeAt(0) * 23) % this.table.length;
    }
    return hash;
  }

  set(key, value) {
    const index = this._hash(key);
    if (!this.table[index]) this.table[index] = [];
    this.table[index].push([key, value]);
  }

  get(key) {
    const index = this._hash(key);
    const bucket = this.table[index];
    if (bucket) {
      for (let [k, v] of bucket) {
        if (k === key) return v;
      }
    }
    return undefined;
  }

  keys() {
    let result = [];
    for (let bucket of this.table) {
      if (bucket) {
        for (let [k] of bucket) result.push(k);
      }
    }
    return result;
  }
}
const ht = new HashTable();

ht.set("name", "Vishnu");
ht.set("age", 25);
ht.set("role", "Instructor");

console.log(ht.get("name"));        // Vishnu

console.log(ht.keys());             // ["name", "age"]

```

## 🧠 Use Cases

| Real-World Problem | Hash Table Role |
| --- | --- |
| Lookup dictionary | Word → definition |
| Count frequency | Char → count |
| Detect duplicates in array | Value → exists |
| Group anagrams | Sorted word → [grouped words] |
| Subarray sum problems | Prefix sum → index |
| LRU Cache | Key → Node in DLL |

## 🧠 What is Separate Chaining?

When two keys hash to the **same index**, you **chain** the entries at that index using a **linked list**.

## 🎯 Goal:

Implement a **Hash Table**:

- Uses an **array** for storage.
- Handles **collisions** using a **linked list** at each index.

## 📦 Structure Breakdown

```
table = [
  null,
  null,
  LinkedList -> [key1, val1] -> [key2, val2],
  ...
]
```

## 🔧 Step-by-Step Implementation

### 1️⃣ Node class (for linked list):

```jsx
class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.next = null;
  }
}
```

### 2️⃣ LinkedList class (used for chaining):

```jsx
class LinkedList {
  constructor() {
    this.head = null;
  }

  insert(key, value) {
    const newNode = new Node(key, value);
    if (!this.head) {
      this.head = newNode;
    } else {
      // Insert at head for simplicity
      newNode.next = this.head;
      this.head = newNode;
    }
  }

  get(key) {
    let current = this.head;
    while (current) {
      if (current.key === key) return current.value;
      current = current.next;
    }
    return undefined
  }

  remove(key) {
    if (!this.head) return;

    if (this.head.key === key) {
      this.head = this.head.next;
      return;
    }

    let curr = this.head;
    while (curr.next && curr.next.key !== key) {
      curr = curr.next;
    }

    if (curr.next) {
      curr.next = curr.next.next;
    }
  }
}
```

### 3️⃣ HashTable with Chaining:

```jsx
class HashTable {
  constructor(size = 53) {
    this.table = new Array(size);
  }

  _hash(key) {
    let hash = 0;
    for (let char of key) {
      hash = (hash + char.charCodeAt(0) * 31) % this.table.length;
    }
    return hash;
  }

  set(key, value) {
    const index = this._hash(key);

    if (!this.table[index]) {
      this.table[index] = new LinkedList();
    }

    this.table[index].insert(key, value);
  }

  get(key) {
    const index = this._hash(key);
    if (this.table[index]) {
      return this.table[index].get(key);
    }
    return undefined;
  }

  remove(key) {
    const index = this._hash(key);
    if (this.table[index]) {
      this.table[index].remove(key);
    }
  }
}
```

## ✅ Usage

```jsx
const ht = new HashTable();

ht.set("name", "Vishnu");
ht.set("age", 25);
ht.set("mane", "CollisionTest"); // intentionally collides with "name" in small tables

console.log(ht.get("name")); // Vishnu
console.log(ht.get("age"));  // 25
console.log(ht.get("mane")); // CollisionTest

ht.remove("name");
console.log(ht.get("name")); // undefined
```

## 💬 Summary (Instructor Style):

> Separate chaining lets us handle multiple values at the same index by building a linked list — one that can grow independently at each slot. It keeps hash table performance consistent, even when collisions occur, and is easier to manage than open addressing for dynamic data.
> 

## 🧠 What is Open Addressing?

When a **collision** occurs (i.e., two keys hash to the same index), **open addressing** tries to find the **next available slot in the array**.

There are three common strategies:

### 🔁 1. **Linear Probing**

> Check the next slot: index + 1, index + 2, ... until an empty spot is found.
> 

### 🔁 2. **Quadratic Probing**

> Skip in a quadratic fashion: index + 1², index + 2², index + 3², etc.
> 

### 🔁 3. **Double Hashing**

> Use a second hash function to compute the next step: index + f2(key)
> 

## 💡 Open Addressing vs Chaining

| Feature | Open Addressing | Separate Chaining |
| --- | --- | --- |
| Storage | Inside array only | Array + linked lists |
| Memory | Compact, cache-friendly | Extra memory for chains |
| Deletion | Tricky (requires special markers) | Easier |
| Load factor | Slower after ~70% fill | Slower only at bucket level |

## 📦 Let's Build: Linear Probing Hash Table (in JS)

### 1️⃣ Setup:

```jsx
class HashTable {
  constructor(size = 10) {
    this.table = new Array(size);
    this.size = size;
    this.count = 0;
  }

  _hash(key) {
    let hash = 0;
    for (let char of key) {
      hash = (hash + char.charCodeAt(0)) % this.size;
    }
    return hash;
  }

  _probe(index) {x
    return (index + 1) % this.size;
  }
```

### 2️⃣ `set()` with Linear Probing:

```jsx
  set(key, value) {
    let index = this._hash(key);
    const start = index;

    while (this.table[index] && this.table[index].key !== key) {
      index = this._probe(index);
      if (index === start) throw new Error("Table is full!");
    }

    this.table[index] = { key, value };
    this.count++;
  }
```

### 3️⃣ `get()` and `delete()`:

```jsx
  get(key) {
    let index = this._hash(key);
    const start = index;

    while (this.table[index]) {
      if (this.table[index].key === key) return this.table[index].value;
      index = this._probe(index);
      if (index === start) break;
    }

    return undefined;
  }

  delete(key) {
    let index = this._hash(key);
    const start = index;

    while (this.table[index]) {
      if (this.table[index].key === key) {
        this.table[index] = { key: "__deleted__", value: null }; // tombstone
        return;
      }
      index = this._probe(index);
      if (index === start) break;
    }
  }
}
```

## ✅ Example Usage:

```jsx
const ht = new HashTable(5);

ht.set("a", 1);
ht.set("b", 2);
ht.set("c", 3); // may collide

console.log(ht.get("a")); // 1
ht.delete("b");
console.log(ht.get("b")); // undefined
```

### Resuse tombstones (optional enhancement)

```jsx
set(key, value) {
  let index = this._hash(key);
  const start = index;
  let firstDeleted = -1;

  while (this.table[index]) {
    if (this.table[index].key === key) {
      this.table[index].value = value;
      return;
    }
    if (this.table[index].key === "__deleted__" && firstDeleted === -1) {
      firstDeleted = index;
    }
    index = this._probe(index);
    if (index === start) throw new Error("Table is full.");
  }

  const targetIndex = firstDeleted !== -1 ? firstDeleted : index;
  this.table[targetIndex] = { key, value };
  this.count++;
}
```

## 🔁 Quadratic Probing Variation

Instead of:

```jsx
index = (index + 1) % size;
```

Do:

```jsx
index = (start + i * i) % size; // where i is the attempt number
```

This spreads probes wider and avoids clustering but can still fail if not properly sized (use prime sizes).

```jsx
class HashTable {
    constructor(size = 10) {
      this.table = new Array(size);
      this.size = size;
      this.count = 0;
    }
  
    _hash(key) {
      let hash = 0;
      for (let char of key) {
        hash = (hash + char.charCodeAt(0)) % this.size;
      }
      return hash;
    }
  
    set(key, value) {
      let index = this._hash(key);
      let i = 1;
      let originalIndex = index;
  
      while (this.table[index] && this.table[index].key !== key && this.table[index].key !== "__deleted__") {
        index = (originalIndex + i * i) % this.size;
        if (i > this.size) throw new Error("Table is full");
        i++;
      }
  
      this.table[index] = { key, value };
      this.count++;
    }
  
    get(key) {
      let index = this._hash(key);
      let i = 1;
      let originalIndex = index;
  
      while (this.table[index]) {
        if (this.table[index].key === key) return this.table[index].value;
        index = (originalIndex + i * i) % this.size;
        if (i > this.size) break;
        i++;
      }
  
      return undefined;
    }
  
    delete(key) {
      let index = this._hash(key);
      let i = 1;
      let originalIndex = index;
  
      while (this.table[index]) {
        if (this.table[index].key === key) {
          this.table[index] = { key: "__deleted__", value: null };
          this.count--;
          return;
        }
        index = (originalIndex + i * i) % this.size;
        if (i > this.size) break;
        i++;
      }
    }
  }
  const ht = new HashTable(7);

ht.set("a", 1);
ht.set("b", 2);
ht.set("c", 3); // may cause collision

console.log(ht.get("a")); // 1
console.log(ht.get("c")); // 3

ht.delete("b");
console.log(ht.get("b")); // undefined

```

## 💬 Summary (Instructor-Style)

> Open addressing avoids extra memory but comes at the cost of probing (looping) to find the right place. Linear probing checks the next cell, quadratic skips ahead, and double hashing uses another hash function. It’s cache-friendly, but deletion and resizing can get complex.
> 

# Load Factor

## 🔷 1️⃣ What is Load Factor?

The **Load Factor** (𝛼) of a hash table tells you **how full the table is**.

### ✅ Formula:

```
Load Factor = number of elements / size of hash table
            = count / table.length
```

### 🔎 Example:

- Hash table size = 10
- You inserted 7 key-value pairs
    
    → Load factor = 7 / 10 = **0.7**
    

### 📊 Why Is It Important?

The **higher** the load factor:

- The **more collisions** will happen
- Lookup, insert, delete all slow down

> 📌 Most hash table implementations keep the load factor below 0.75 (75%).
> 

## 🔁 2️⃣ What is Resizing?

When the **load factor exceeds a threshold**, the table is **resized** (usually **doubled** in size), and **all keys are rehashed** into the new array.

This ensures:

- Fewer collisions
- Performance stays near **O(1)**

### ⚙️ Resizing Flow:

```
text
Copy code
1. Load factor > threshold (say 0.75)
2. Double the table size (or to next prime)
3. Create new empty array
4. Re-hash each existing key into new table

```

### 📦 JavaScript Example with Resize:

```jsx
class HashTable {
  constructor(size = 5) {
    this.table = new Array(size);
    this.count = 0;
  }

  _hash(key) {
    let hash = 0;
    for (let char of key) {
      hash = (hash + char.charCodeAt(0)) % this.table.length;
    }
    return hash;
  }

  _resize() {
    const oldTable = this.table;
    this.table = new Array(oldTable.length * 2);
    this.count = 0;

    for (let entry of oldTable) {
      if (entry) {
        this.set(entry.key, entry.value);
      }
    }
  }

  set(key, value) {
    const loadFactor = this.count / this.table.length;
    if (loadFactor > 0.75) this._resize();

    let index = this._hash(key);
    while (this.table[index]) {
      if (this.table[index].key === key) break;
      index = (index + 1) % this.table.length;
    }

    this.table[index] = { key, value };
    this.count++;
  }

  get(key) {
    let index = this._hash(key);
    while (this.table[index]) {
      if (this.table[index].key === key) return this.table[index].value;
      index = (index + 1) % this.table.length;
    }
    return undefined;
  }
}

// Instantiate HashTable
const ht = new HashTable(5);

// Add key-value pairs
ht.set("name", "Vishnu");
ht.set("age", 25);
ht.set("role", "Instructor");
ht.set("location", "India");

// Retrieve values
console.log(ht.get("name"));      // Vishnu
console.log(ht.get("age"));       // 25
console.log(ht.get("role"));      // Instructor
console.lo
x
```

## 📌 Rule of Thumb (Interview Ready):

> 🔹 Keep Load Factor < 0.75
> 
> 
> 🔹 Resize by doubling (or using next prime)
> 
> 🔹 Rehash every element when resizing
>